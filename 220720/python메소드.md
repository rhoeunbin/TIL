**함수 -  인풋을 주면  아웃풋이 나옴**

**객체 - 속성과 메소드 모두 존재**



객체 지향 프로그래밍

```python
#self : 호출하는 인스턴스를 파이썬 내부적으로 전달해줌

class Person :
    #생성자! 인스턴스가 생성될 때 어떠한 작업
    #사람이라면 이름을 가지고 있음
    #인스턴스를 만들 때는 이름 정보를 받고 싶다
    def __init__(self,name): #__init__ : 자동 호출
        #그 인스턴스의 이름을 name으로 해달라는 코드 필요
      
        self.name=name  #그 이름의 속성 만들어줌
          #개별 인스턴스에 각각 name 속성 지정
         
    # self : 호출하는 인스턴스를 파이썬 내부적으로 전달해줌
    # jimin.greeting() 이렇게 호출되면
    # 이런 느낌처럼 Person.greeting(jimin)
    def greeting(self):
        print(f'안녕하세요, {self.name}입니다.')
        
#Person 클래스의 인스턴스인 iu 생성
iu = Person('아이유')
print(iu.name)
jimin = Person('지민')
print(jimin.name)
```



- 클래스 속성(attribute)
  - 한 클래스의 모든 인스턴스라도 똑같은 값을 가지고 있는 속성
  - 클래스 선언 내부에서 정의

```python
class Circle : 
    pi = 3.14

    c1 = Circle()
    c2 = Circle()
    #c1, c2 는 인스턴스
    
```

- 인스턴스와 클래스 간의 이름 공간(namespace)
  - 클래스를 정의하면 ,클래스와 해당하는 이름 공간 생성
  - 인스턴스를 만들면 ,인스턴스 객체가 생성되고 이름 공간 생성
  - 인스턴스에서 특정 속성에 접근하면, 인스턴스 -클래스 순으로 탐색



### 메소드 정리

#### 인스턴스 메소드

> 호출한 인스턴스를 의미하는 셀프

#### 클래스 메소드

- 클래스가 사용할 메소드
- @classmethod 데코레이터를 사용하여 정의
  - 데코레이터(@) : 함수를 어떤 함수로 꾸며서 새로운 기능 부여
- 호출 시 ,첫번째 인자로 클래스(cls) 전달



#### 스태틱 메소드

인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메소드(기능만 할 때)

=> 인스턴스, 클래스 내에서 절대 쓸 수 없다!! (@staticmethod)



✍*cls, self 는 예약어가 아니고 관용적 표현*





💡*함수 내부에서 값을 쓰고 싶으면?*

*정의할 때 이름을 지어놓고. 호출할 때 값을 넘기기*



#### 객체지향의 핵심

- 추상화

- 상속 

  - 클래스 간의 부모-자식 관계(자동차 - 트럭,버스,차)

  ​        -> 메소드가 정의되지 않아도 상속받음

  - super() - 상위에 있는 부모 클래스 호출(중복된 코드 대신 호출 가능
  - 모든 클래스는 object로부터 상속

  - 다중 상속도 가능

- 다형성 

  - 동일한 메소드가 클래스에 따라 다르게 행동할 수 있음
  - 메소드 오버라이딩(덮어쓰기) 가능

- 캡슐화(굳이 알 필요 X)

  - public(어디서나 호출 가능), protected(부모/자식), private(본인만 - 클래스 그 자체)
  - 실제로 파이썬은 수단과 방법을 써서 접근 가능







